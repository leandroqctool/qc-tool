// Enterprise Quality Pillars System
import { neon } from '@neondatabase/serverless'
import { aiAnalysisManager } from './ai-analysis'

export interface QualityPillar {
  id: string
  name: string
  description: string
  category: 'technical' | 'creative' | 'content' | 'process'
  weight: number // 0-1, importance in overall score
  color: string
  icon: string
  criteria: QualityCriterion[]
  isActive: boolean
  tenantId: string
  createdAt: Date
  updatedAt: Date
}

export interface QualityCriterion {
  id: string
  pillarId: string
  name: string
  description: string
  type: 'boolean' | 'numeric' | 'scale' | 'text' | 'checklist'
  weight: number // 0-1, importance within pillar
  config: CriterionConfig
  validationRules: ValidationRule[]
  isRequired: boolean
  order: number
}

export interface CriterionConfig {
  // Boolean criteria
  trueLabel?: string
  falseLabel?: string
  
  // Numeric criteria
  minValue?: number
  maxValue?: number
  unit?: string
  precision?: number
  
  // Scale criteria (1-5, 1-10, etc.)
  scaleMin?: number
  scaleMax?: number
  scaleLabels?: string[]
  
  // Text criteria
  maxLength?: number
  placeholder?: string
  
  // Checklist criteria
  options?: {
    id: string
    label: string
    weight: number
  }[]
}

export interface ValidationRule {
  type: 'required' | 'min' | 'max' | 'range' | 'pattern' | 'custom'
  value?: number | string
  message: string
}

export interface QualityAssessment {
  id: string
  fileId: string
  tenantId: string
  reviewerId: string
  reviewerName: string
  status: 'draft' | 'submitted' | 'approved' | 'rejected'
  overallScore: number // 0-100
  pillarScores: PillarScore[]
  criterionScores: CriterionScore[]
  notes?: string
  recommendations: string[]
  createdAt: Date
  updatedAt: Date
  submittedAt?: Date
  metadata: {
    timeSpent: number // minutes
    revisionsCount: number
    confidenceLevel: 'low' | 'medium' | 'high'
    flags: QualityFlag[]
  }
}

export interface PillarScore {
  pillarId: string
  pillarName: string
  score: number // 0-100
  weight: number
  contributesToOverall: number // weighted contribution
  status: 'excellent' | 'good' | 'fair' | 'poor' | 'critical'
  notes?: string
}

export interface CriterionScore {
  criterionId: string
  criterionName: string
  pillarId: string
  value: unknown // The actual assessment value
  score: number // 0-100, normalized score
  weight: number
  isPassing: boolean
  notes?: string
}

export interface QualityFlag {
  type: 'critical' | 'warning' | 'info' | 'suggestion'
  message: string
  pillarId?: string
  criterionId?: string
  autoGenerated: boolean
}

export interface QualityTemplate {
  id: string
  name: string
  description: string
  tenantId: string
  category: string
  pillars: string[] // pillar IDs
  settings: {
    passingScore: number // minimum overall score to pass
    pillarRequirements: {
      pillarId: string
      minScore: number
      isRequired: boolean
    }[]
    autoFlags: {
      enabled: boolean
      thresholds: {
        critical: number
        warning: number
      }
    }
  }
  isDefault: boolean
  createdAt: Date
  updatedAt: Date
}

export interface QualityReport {
  assessmentId: string
  fileId: string
  fileName: string
  overallScore: number
  status: string
  reviewedBy: string
  reviewedAt: Date
  summary: {
    strengths: string[]
    improvements: string[]
    criticalIssues: string[]
  }
  pillarBreakdown: {
    pillarName: string
    score: number
    status: string
    topCriteria: {
      name: string
      score: number
      notes?: string
    }[]
  }[]
  recommendations: {
    priority: 'high' | 'medium' | 'low'
    category: string
    description: string
    estimatedImpact: number
  }[]
  comparisons: {
    averageScore: number
    industryBenchmark?: number
    previousAssessments: {
      date: Date
      score: number
    }[]
  }
}

export interface QualityAnalytics {
  period: { from: Date; to: Date }
  totalAssessments: number
  averageScore: number
  scoreDistribution: {
    excellent: number // 90-100
    good: number      // 75-89
    fair: number      // 60-74
    poor: number      // 40-59
    critical: number  // 0-39
  }
  pillarPerformance: {
    pillarName: string
    averageScore: number
    trend: number // percentage change
    topIssues: string[]
  }[]
  reviewerPerformance: {
    reviewerId: string
    reviewerName: string
    assessmentsCount: number
    averageScore: number
    consistency: number // how consistent their scoring is
    avgTimeSpent: number
  }[]
  trends: {
    date: Date
    averageScore: number
    assessmentCount: number
  }[]
  insights: {
    type: 'improvement' | 'decline' | 'stable' | 'anomaly'
    message: string
    data: Record<string, unknown>
  }[]
}

// Quality Pillars Manager
export class QualityPillarsManager {
  private sql: ReturnType<typeof neon>

  constructor() {
    this.sql = neon(process.env.DATABASE_URL!)
  }

  // Pillar Management
  async createPillar(pillar: Omit<QualityPillar, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const pillarId = `pillar_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    const fullPillar: QualityPillar = {
      ...pillar,
      id: pillarId,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    await this.storePillar(fullPillar)
    console.log(`Quality pillar created: ${pillarId}`)
    return pillarId
  }

  // Create Assessment
  async createAssessment(fileId: string, templateId: string, reviewerId: string, tenantId: string): Promise<string> {
    const assessmentId = `assessment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    const template = await this.getTemplate(templateId)
    if (!template) {
      throw new Error('Template not found')
    }

    const pillars = await this.getPillarsByIds(template.pillars)
    
    // Initialize pillar and criterion scores
    const pillarScores: PillarScore[] = pillars.map(pillar => ({
      pillarId: pillar.id,
      pillarName: pillar.name,
      score: 0,
      weight: pillar.weight,
      contributesToOverall: 0,
      status: 'fair' as const,
      notes: undefined
    }))

    const criterionScores: CriterionScore[] = pillars.flatMap(pillar =>
      pillar.criteria.map(criterion => ({
        criterionId: criterion.id,
        criterionName: criterion.name,
        pillarId: pillar.id,
        value: null,
        score: 0,
        weight: criterion.weight,
        isPassing: false,
        notes: undefined
      }))
    )

    const assessment: QualityAssessment = {
      id: assessmentId,
      fileId,
      tenantId,
      reviewerId,
      reviewerName: 'Reviewer Name', // Would fetch from user
      status: 'draft',
      overallScore: 0,
      pillarScores,
      criterionScores,
      notes: undefined,
      recommendations: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: {
        timeSpent: 0,
        revisionsCount: 0,
        confidenceLevel: 'medium',
        flags: []
      }
    }

    await this.storeAssessment(assessment)
    console.log(`Quality assessment created: ${assessmentId}`)
    return assessmentId
  }

  // Update Assessment
  async updateAssessment(assessmentId: string, updates: {
    criterionScores?: Partial<CriterionScore>[]
    notes?: string
    status?: QualityAssessment['status']
  }): Promise<void> {
    const assessment = await this.getAssessment(assessmentId)
    if (!assessment) {
      throw new Error('Assessment not found')
    }

    // Update criterion scores
    if (updates.criterionScores) {
      for (const update of updates.criterionScores) {
        const criterion = assessment.criterionScores.find(c => c.criterionId === update.criterionId)
        if (criterion) {
          Object.assign(criterion, update)
        }
      }
    }

    // Update notes and status
    if (updates.notes !== undefined) assessment.notes = updates.notes
    if (updates.status) assessment.status = updates.status

    // Recalculate scores
    await this.calculateScores(assessment)

    // Generate flags and recommendations
    assessment.metadata.flags = await this.generateQualityFlags(assessment)
    assessment.recommendations = await this.generateRecommendations(assessment)

    assessment.updatedAt = new Date()
    if (updates.status === 'submitted') {
      assessment.submittedAt = new Date()
    }

    await this.updateAssessmentRecord(assessment)
    console.log(`Assessment updated: ${assessmentId}`)
  }

  // Calculate Scores
  private async calculateScores(assessment: QualityAssessment): Promise<void> {
    // Calculate pillar scores
    for (const pillarScore of assessment.pillarScores) {
      const pillarCriteria = assessment.criterionScores.filter(c => c.pillarId === pillarScore.pillarId)
      
      if (pillarCriteria.length === 0) {
        pillarScore.score = 0
        continue
      }

      // Weighted average of criterion scores
      const totalWeight = pillarCriteria.reduce((sum, c) => sum + c.weight, 0)
      const weightedSum = pillarCriteria.reduce((sum, c) => sum + (c.score * c.weight), 0)
      
      pillarScore.score = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0
      pillarScore.contributesToOverall = pillarScore.score * pillarScore.weight
      pillarScore.status = this.getScoreStatus(pillarScore.score)
    }

    // Calculate overall score
    const totalPillarWeight = assessment.pillarScores.reduce((sum, p) => sum + p.weight, 0)
    const totalContribution = assessment.pillarScores.reduce((sum, p) => sum + p.contributesToOverall, 0)
    
    assessment.overallScore = totalPillarWeight > 0 ? Math.round(totalContribution / totalPillarWeight) : 0
  }

  // Generate Quality Flags
  private async generateQualityFlags(assessment: QualityAssessment): Promise<QualityFlag[]> {
    const flags: QualityFlag[] = []

    // Overall score flags
    if (assessment.overallScore < 40) {
      flags.push({
        type: 'critical',
        message: 'Overall quality score is critically low',
        autoGenerated: true
      })
    } else if (assessment.overallScore < 60) {
      flags.push({
        type: 'warning',
        message: 'Overall quality score is below acceptable threshold',
        autoGenerated: true
      })
    }

    // Pillar-specific flags
    for (const pillar of assessment.pillarScores) {
      if (pillar.score < 30) {
        flags.push({
          type: 'critical',
          message: `${pillar.pillarName} pillar requires immediate attention`,
          pillarId: pillar.pillarId,
          autoGenerated: true
        })
      } else if (pillar.score < 50) {
        flags.push({
          type: 'warning',
          message: `${pillar.pillarName} pillar shows areas for improvement`,
          pillarId: pillar.pillarId,
          autoGenerated: true
        })
      }
    }

    // Criterion-specific flags
    for (const criterion of assessment.criterionScores) {
      if (criterion.weight > 0.7 && criterion.score < 40) {
        flags.push({
          type: 'warning',
          message: `High-priority criterion "${criterion.criterionName}" scored poorly`,
          pillarId: criterion.pillarId,
          criterionId: criterion.criterionId,
          autoGenerated: true
        })
      }
    }

    return flags
  }

  // Generate Recommendations
  private async generateRecommendations(assessment: QualityAssessment): Promise<string[]> {
    const recommendations: string[] = []

    // Find lowest scoring pillars
    const sortedPillars = [...assessment.pillarScores].sort((a, b) => a.score - b.score)
    const lowestPillar = sortedPillars[0]

    if (lowestPillar && lowestPillar.score < 70) {
      recommendations.push(`Focus on improving ${lowestPillar.pillarName} - currently the weakest area`)
    }

    // Find high-impact improvements
    const highImpactCriteria = assessment.criterionScores
      .filter(c => c.weight > 0.6 && c.score < 60)
      .sort((a, b) => b.weight - a.weight)

    if (highImpactCriteria.length > 0) {
      const criterion = highImpactCriteria[0]
      recommendations.push(`Address "${criterion.criterionName}" for maximum quality impact`)
    }

    // Overall recommendations
    if (assessment.overallScore < 60) {
      recommendations.push('Consider additional review cycles to meet quality standards')
    } else if (assessment.overallScore > 90) {
      recommendations.push('Excellent quality - consider this as a best practice example')
    }

    return recommendations
  }

  // Generate Quality Report
  async generateReport(assessmentId: string): Promise<QualityReport> {
    const assessment = await this.getAssessment(assessmentId)
    if (!assessment) {
      throw new Error('Assessment not found')
    }

    // Get file information
    const fileName = await this.getFileName(assessment.fileId)

    // Generate summary
    const strengths = assessment.pillarScores
      .filter(p => p.score >= 80)
      .map(p => `Strong ${p.pillarName.toLowerCase()} quality`)

    const improvements = assessment.pillarScores
      .filter(p => p.score >= 60 && p.score < 80)
      .map(p => `${p.pillarName} could be enhanced`)

    const criticalIssues = assessment.pillarScores
      .filter(p => p.score < 60)
      .map(p => `${p.pillarName} requires attention`)

    // Pillar breakdown
    const pillarBreakdown = assessment.pillarScores.map(pillar => ({
      pillarName: pillar.pillarName,
      score: pillar.score,
      status: pillar.status,
      topCriteria: assessment.criterionScores
        .filter(c => c.pillarId === pillar.pillarId)
        .sort((a, b) => b.score - a.score)
        .slice(0, 3)
        .map(c => ({
          name: c.criterionName,
          score: c.score,
          notes: c.notes
        }))
    }))

    // Generate prioritized recommendations
    const recommendations = assessment.recommendations.map((rec, index) => ({
      priority: index === 0 ? 'high' as const : index < 3 ? 'medium' as const : 'low' as const,
      category: 'Quality Improvement',
      description: rec,
      estimatedImpact: Math.max(10, 100 - assessment.overallScore)
    }))

    // Mock comparisons data
    const comparisons = {
      averageScore: 75, // Would calculate from database
      industryBenchmark: 78,
      previousAssessments: [
        { date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), score: 72 },
        { date: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000), score: 68 }
      ]
    }

    return {
      assessmentId,
      fileId: assessment.fileId,
      fileName,
      overallScore: assessment.overallScore,
      status: assessment.status,
      reviewedBy: assessment.reviewerName,
      reviewedAt: assessment.submittedAt || assessment.updatedAt,
      summary: {
        strengths,
        improvements,
        criticalIssues
      },
      pillarBreakdown,
      recommendations,
      comparisons
    }
  }

  // Analytics
  async getQualityAnalytics(tenantId: string, period: { from: Date; to: Date }): Promise<QualityAnalytics> {
    console.log(`Generating quality analytics for tenant: ${tenantId}`)

    const assessments = await this.getAssessments(tenantId, period)
    
    const totalAssessments = assessments.length
    const averageScore = assessments.length > 0 
      ? assessments.reduce((sum, a) => sum + a.overallScore, 0) / assessments.length 
      : 0

    // Score distribution
    const scoreDistribution = {
      excellent: assessments.filter(a => a.overallScore >= 90).length,
      good: assessments.filter(a => a.overallScore >= 75 && a.overallScore < 90).length,
      fair: assessments.filter(a => a.overallScore >= 60 && a.overallScore < 75).length,
      poor: assessments.filter(a => a.overallScore >= 40 && a.overallScore < 60).length,
      critical: assessments.filter(a => a.overallScore < 40).length
    }

    // Pillar performance (mock data)
    const pillarPerformance = [
      { pillarName: 'Technical Quality', averageScore: 82, trend: 5, topIssues: ['Resolution issues', 'Color accuracy'] },
      { pillarName: 'Creative Excellence', averageScore: 78, trend: -2, topIssues: ['Composition', 'Visual hierarchy'] },
      { pillarName: 'Content Accuracy', averageScore: 85, trend: 3, topIssues: ['Typography', 'Brand guidelines'] },
      { pillarName: 'Process Compliance', averageScore: 76, trend: 1, topIssues: ['File naming', 'Metadata'] }
    ]

    // Reviewer performance (mock data)
    const reviewerPerformance = [
      { reviewerId: 'rev_1', reviewerName: 'John Smith', assessmentsCount: 45, averageScore: 78, consistency: 85, avgTimeSpent: 25 },
      { reviewerId: 'rev_2', reviewerName: 'Sarah Johnson', assessmentsCount: 38, averageScore: 82, consistency: 92, avgTimeSpent: 32 }
    ]

    // Trends (mock data)
    const trends = this.generateTrendData(period)

    // Insights
    const insights = this.generateInsights(assessments, pillarPerformance)

    return {
      period,
      totalAssessments,
      averageScore,
      scoreDistribution,
      pillarPerformance,
      reviewerPerformance,
      trends,
      insights
    }
  }

  // AI Integration
  async generateAIAssessment(fileId: string, templateId: string): Promise<Partial<QualityAssessment>> {
    console.log(`Generating AI assessment for file: ${fileId}`)

    // Get AI analysis
    const aiAnalysis = await aiAnalysisManager.performAIAnalysis(fileId, 'user_ai', 'tenant_1')

    // Convert AI analysis to quality assessment format
    const template = await this.getTemplate(templateId)
    if (!template) {
      throw new Error('Template not found')
    }

    // Mock AI-generated scores based on AI analysis
    const mockCriterionScores: CriterionScore[] = [
      {
        criterionId: 'tech_resolution',
        criterionName: 'Image Resolution',
        pillarId: 'pillar_technical',
        value: '300 DPI',
        score: 85,
        weight: 0.8,
        isPassing: true,
        notes: 'Good resolution for print quality'
      },
      {
        criterionId: 'creative_composition',
        criterionName: 'Visual Composition',
        pillarId: 'pillar_creative',
        value: 'Rule of thirds applied',
        score: 78,
        weight: 0.9,
        isPassing: true,
        notes: 'Strong composition with good balance'
      }
    ]

    return {
      overallScore: aiAnalysis.overallScore,
      criterionScores: mockCriterionScores,
      recommendations: aiAnalysis.recommendations.map(r => r.description),
      metadata: {
        timeSpent: 2, // AI is fast
        revisionsCount: 0,
        confidenceLevel: aiAnalysis.confidence > 0.8 ? 'high' : aiAnalysis.confidence > 0.6 ? 'medium' : 'low',
        flags: []
      }
    }
  }

  // Helper Methods
  private getScoreStatus(score: number): PillarScore['status'] {
    if (score >= 90) return 'excellent'
    if (score >= 75) return 'good'
    if (score >= 60) return 'fair'
    if (score >= 40) return 'poor'
    return 'critical'
  }

  private generateTrendData(period: { from: Date; to: Date }): QualityAnalytics['trends'] {
    const trends: QualityAnalytics['trends'] = []
    const days = Math.ceil((period.to.getTime() - period.from.getTime()) / (1000 * 60 * 60 * 24))
    
    for (let i = 0; i < days; i++) {
      const date = new Date(period.from.getTime() + i * 24 * 60 * 60 * 1000)
      trends.push({
        date,
        averageScore: 75 + Math.random() * 20, // Mock trending data
        assessmentCount: Math.floor(Math.random() * 10) + 2
      })
    }
    
    return trends
  }

  private generateInsights(assessments: QualityAssessment[], pillarPerformance: QualityAnalytics['pillarPerformance']): QualityAnalytics['insights'] {
    const insights: QualityAnalytics['insights'] = []

    // Score improvement insight
    if (assessments.length > 10) {
      const recent = assessments.slice(-5).reduce((sum, a) => sum + a.overallScore, 0) / 5
      const older = assessments.slice(0, 5).reduce((sum, a) => sum + a.overallScore, 0) / 5
      
      if (recent > older + 5) {
        insights.push({
          type: 'improvement',
          message: `Quality scores have improved by ${Math.round(recent - older)} points recently`,
          data: { recent, older, improvement: recent - older }
        })
      }
    }

    // Pillar performance insight
    const lowestPillar = pillarPerformance.reduce((min, p) => p.averageScore < min.averageScore ? p : min)
    if (lowestPillar.averageScore < 70) {
      insights.push({
        type: 'decline',
        message: `${lowestPillar.pillarName} consistently scores below target`,
        data: { pillar: lowestPillar.pillarName, score: lowestPillar.averageScore }
      })
    }

    return insights
  }

  // Database operations (placeholders)
  private async storePillar(pillar: QualityPillar): Promise<void> {
    console.log(`Storing pillar: ${pillar.id}`)
  }

  private async getPillarsByIds(pillarIds: string[]): Promise<QualityPillar[]> {
    console.log(`Getting pillars: ${pillarIds.join(', ')}`)
    return []
  }

  private async getTemplate(templateId: string): Promise<QualityTemplate | null> {
    console.log(`Getting template: ${templateId}`)
    return null
  }

  private async storeAssessment(assessment: QualityAssessment): Promise<void> {
    console.log(`Storing assessment: ${assessment.id}`)
  }

  private async getAssessment(assessmentId: string): Promise<QualityAssessment | null> {
    console.log(`Getting assessment: ${assessmentId}`)
    return null
  }

  private async updateAssessmentRecord(assessment: QualityAssessment): Promise<void> {
    console.log(`Updating assessment: ${assessment.id}`)
  }

  private async getAssessments(tenantId: string, period: { from: Date; to: Date }): Promise<QualityAssessment[]> {
    console.log(`Getting assessments for tenant: ${tenantId}`)
    return []
  }

  private async getFileName(fileId: string): Promise<string> {
    console.log(`Getting file name for: ${fileId}`)
    return 'sample_file.jpg'
  }
}

// Default Quality Pillars
export const DEFAULT_QUALITY_PILLARS: Omit<QualityPillar, 'id' | 'tenantId' | 'createdAt' | 'updatedAt'>[] = [
  {
    name: 'Technical Quality',
    description: 'Technical specifications and file quality',
    category: 'technical',
    weight: 0.25,
    color: '#3b82f6',
    icon: 'settings',
    isActive: true,
    criteria: [
      {
        id: 'tech_resolution',
        pillarId: '',
        name: 'Image Resolution',
        description: 'Appropriate resolution for intended use',
        type: 'numeric',
        weight: 0.8,
        config: { minValue: 72, maxValue: 300, unit: 'DPI' },
        validationRules: [{ type: 'min', value: 72, message: 'Resolution must be at least 72 DPI' }],
        isRequired: true,
        order: 1
      },
      {
        id: 'tech_filesize',
        pillarId: '',
        name: 'File Size',
        description: 'Optimal file size for delivery',
        type: 'scale',
        weight: 0.6,
        config: { scaleMin: 1, scaleMax: 5, scaleLabels: ['Too large', 'Large', 'Optimal', 'Small', 'Too small'] },
        validationRules: [],
        isRequired: true,
        order: 2
      }
    ]
  },
  {
    name: 'Creative Excellence',
    description: 'Visual design and creative execution',
    category: 'creative',
    weight: 0.3,
    color: '#8b5cf6',
    icon: 'palette',
    isActive: true,
    criteria: [
      {
        id: 'creative_composition',
        pillarId: '',
        name: 'Visual Composition',
        description: 'Layout, balance, and visual hierarchy',
        type: 'scale',
        weight: 0.9,
        config: { scaleMin: 1, scaleMax: 10, scaleLabels: [] },
        validationRules: [{ type: 'min', value: 6, message: 'Composition must score at least 6/10' }],
        isRequired: true,
        order: 1
      },
      {
        id: 'creative_color',
        pillarId: '',
        name: 'Color Usage',
        description: 'Color harmony and brand compliance',
        type: 'scale',
        weight: 0.8,
        config: { scaleMin: 1, scaleMax: 10 },
        validationRules: [],
        isRequired: true,
        order: 2
      }
    ]
  },
  {
    name: 'Content Accuracy',
    description: 'Text, messaging, and brand compliance',
    category: 'content',
    weight: 0.25,
    color: '#10b981',
    icon: 'file-text',
    isActive: true,
    criteria: [
      {
        id: 'content_spelling',
        pillarId: '',
        name: 'Spelling & Grammar',
        description: 'Correct spelling and grammar',
        type: 'boolean',
        weight: 1.0,
        config: { trueLabel: 'Correct', falseLabel: 'Has errors' },
        validationRules: [{ type: 'required', message: 'Spelling check is required' }],
        isRequired: true,
        order: 1
      },
      {
        id: 'content_brand',
        pillarId: '',
        name: 'Brand Guidelines',
        description: 'Adherence to brand standards',
        type: 'checklist',
        weight: 0.9,
        config: {
          options: [
            { id: 'logo', label: 'Logo placement correct', weight: 1 },
            { id: 'fonts', label: 'Approved fonts used', weight: 1 },
            { id: 'colors', label: 'Brand colors accurate', weight: 1 }
          ]
        },
        validationRules: [],
        isRequired: true,
        order: 2
      }
    ]
  },
  {
    name: 'Process Compliance',
    description: 'Workflow and delivery standards',
    category: 'process',
    weight: 0.2,
    color: '#f59e0b',
    icon: 'check-circle',
    isActive: true,
    criteria: [
      {
        id: 'process_naming',
        pillarId: '',
        name: 'File Naming',
        description: 'Follows naming convention',
        type: 'boolean',
        weight: 0.7,
        config: { trueLabel: 'Correct', falseLabel: 'Incorrect' },
        validationRules: [],
        isRequired: true,
        order: 1
      },
      {
        id: 'process_metadata',
        pillarId: '',
        name: 'Metadata Complete',
        description: 'All required metadata fields filled',
        type: 'boolean',
        weight: 0.8,
        config: { trueLabel: 'Complete', falseLabel: 'Missing' },
        validationRules: [],
        isRequired: true,
        order: 2
      }
    ]
  }
]

// Export quality pillars manager instance
export const qualityPillarsManager = new QualityPillarsManager()
